# QuickSort

## 정해가 틀림에 따라 내일까지 문제 수정 예정입니다.

### 시간 제한 1초, 메모리 제한 512mb

![스크린샷 2024-01-27 오후 2.06.38.png](QuickSort%20d076a924b1e7461a82350347dcf3bd9d/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2024-01-27_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_2.06.38.png)

위의 사진은 퀵 소트를 수행하는 python code이다. arr은 $N$개의 중복되지 않는 원소들을 가진 리스트이며, $r$에는 $0$에서 $length - 1$까지의 정수에서 동일한 확률로 하나를 뽑은 값이 존재한다.

이때 출력되는 값 depth의 기댓값을 구해보자!

## 입력

첫 번째 줄에 arr에 존재하는 원소의 갯수 $N(1 ≤ N ≤ 1000)$이 주어진다.

두 번째 줄에 arr에 존재하는 $N$개의 원소 $a_i(1 ≤ a_i ≤ 10^9)$가 공백으로 구분지어 들어온다. $(i \neq j)$이면 $(a_i \neq a_j)$이다. 

## 출력

첫 번째 줄에 출력되는 depth의 기댓값을 출력한다. 정답과의 절대/상대 오차는 $10^{-6}$까지 허용한다. 

## 풀이

- arr의 원소들은 답을 도출해내는데 관련은 없음. 원소의 갯수 $N$만 답을 도출해내는데 필요.
- $dp[n] = \frac{1}{n} \times \sum_{k = 0}^{n - 1} max(dp[k], dp[n - k - 1])$임은 간단하게 나온다.
- $dp[1] = 0, dp[2] = 1$ 을 초기항으로 삼고 돌리면 됨.
- $dp[i] < dp[i + 1]$을 이용한 $O(n)$ 누적 합 풀이도 존재하나 굳이 정해로 삼고 싶지 않았음.
