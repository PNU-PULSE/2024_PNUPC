# 공 굴리기

- 시간 제한: 1초
- 메모리 제한: 128mb

루트 노드가 $1$이고, 노드의 개수가 $2^{N} - 1$인 포화 이진 트리가 있다. 트리의 $i(1 ≤ i ≤ 2^{N - 1} - 1)$번 노드의 왼쪽 자식은 $2i$번 노드, 오른쪽 자식은 $2i + 1$번 노드이다. 산지니는 이 포화 이진 트리에 공을 $2^{N} - 1$번 굴려서 각 노드마다 공을 한 개씩 배치하려고 한다. 공 굴리기 규칙은 다음과 같다.

1. 자식 노드가 존재하지 않거나 자식 노드들에 모두 공이 존재한다면, 공은 그 노드에서 정지한다.
2. 두 자식 노드가 모두 비어있다면, 각각 자식 노드를 루트 노드로 하는 두 서브 트리의 무게를 비교해서, 무게가 더 작은 서브 트리의 루트 노드로 공이 굴러간다. 서브 트리의 무게란, **각 서브 트리에 존재하는 공의 개수**이다. 만약 **현재 노드가 $1$번 노드가 아니고 두 서브 트리의 무게가 동일하다면**, 현재 노드 번호가 짝수일 경우 현재 노드의 왼쪽 자식 노드를 선택하고, 현재 노드 번호가 홀수인 경우 현재 노드의 오른쪽 자식 노드를 선택한다. 
3. 두 자식 노드 중 하나만 비어있다면, 비어 있는 노드를 선택한다. 

—그림 예제 추가 예정—

산지니는 공을 굴리기 전, $K$번째에 공을 굴릴 때 굴린 공이 어떻게 굴러 가는지 미리 알고 싶어졌다. 산지니를 위해 우리가 대신 구해주자!

## 입력

첫 번째 줄에 두 정수 $N, K$가 공백으로 구분되어 주어진다.

## 출력

첫 번째 줄에 $K$번째에 공을 굴릴 때 굴린 공이 지나가는 노드의 번호를 공백으로 구분하여 차례대로 출력한다.

## 제한

$1 ≤ N ≤ 15$(Easy)

$1 ≤ N ≤ 40$(Hard)

$1 ≤ K ≤ 2^{N} - 1$

## 예제 1

### 입력

```
3 2
```

### 출력

```
1 3 7
```

## 노트
문제의 답이 C++의 32비트 정수형인 int를 넘을 수 있으므로 64비트 정수형인 long long을 사용해야 한다.

## 예상 난이도

- 실2(Easy)
  
- 골3(Hard)

## 출제 의도
- https://school.programmers.co.kr/learn/courses/30/lessons/150367 에서 영향을 받음

## 사용 알고리즘

### Easy

 - 구현
 - DFS

### Hard

 - 수학
 - 분할 정복

## 풀이

### Easy

- 공을 한 번 굴릴 때 최대로 걸리는 시간 복잡도는 $O(N)$. 공은 총 $2^{N} - 1$번 굴릴 수 있으므로 Naive하게 $O(N \times 2^{N})$의 시간복잡도로 풀 수 있음.

### Hard
- Easy에서의 방법을 사용한다면 $O(2^N)$의 공간복잡도와 $O(N \times 2^{N})$의 시간복잡도로 AC를 받을 수 없음.
- 루트 노드에서부터 $i$번째 정점까지의 거리를 $d_i$라고 하고, 공이 채워지는 순서의 번호를 $X_i$라고 할 때, 임의의 $d_i < d_j$인 $i, j$에 대해 $X_j < X_i$임. 즉 $K$번째 공의 위치를 $t$라고 할 때, $d_t$의 값을 특정할 수 있음.
- 채워지는 순서가 서브 트리 단위로 대칭됨을 알 수 있음.
- 문제의 조건에 의해 $K$번째 공이 위치한 노드를 $P$라고 할 때, P가 1이 될 때까지 2를 나누는 방법으로 지나간 정점들을 구할 수 있음.
- 분할 정복을 사용해서 $O(log(2^N)) = O(N)$의 시간복잡도로 문제를 풀 수 있음.

![IMG_0780.jpeg](IMG_0780.jpeg)
